<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Beach Volley Scheduler</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f7f7f7; }
        header { background: #ff9800; color: white; padding: 10px; text-align: center; }
        .container { padding: 20px; display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 10px; }
        .day { background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 4px rgba[0,0,0,0.1); text-align: center; }
        button { background: #ff9800; color: white; border: none; padding: 5px; margin: 2px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #e68a00; }
        input[type="text"], input[type="tel"] { width: 90%; margin: 3px 0; padding: 5px; border-radius: 4px; border: 1px solid #ccc; }
        .guest-names { margin-top: 5px; text-align: left; font-size: 0.9em; }
        .guest-names input { width: 100%; margin-bottom: 3px; }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4CAF50;
            color: white;
            padding: 12px;
            border-radius: 4px;
            z-index: 1000;
            display: none;
        }
        .participant-list { margin-top: 10px; text-align: left; font-size: 0.9em; }
    </style>
</head>
<body>
<header>
    <h1>Beach Volley Scheduler</h1>
</header>
<div id="login" style="padding:20px; display:none;">
    <h3>Inserisci i tuoi dati</h3>
    <input type="text" id="name" placeholder="Nome" required><br><br>
    <input type="tel" id="phone" placeholder="Telefono" required><br><br>
    <button onclick="saveUser()">Salva</button>
</div>
<div id="main" style="display:none;">
    <div style="padding: 0 20px; display: flex; justify-content: space-between; align-items: center;">
        <h3>Calendario prossime 2 settimane</h3>
        <button onclick="refreshData()">Aggiorna</button>
    </div>
    <div class="container" id="eventsGrid"></div>
</div>
<div id="toast" class="toast"></div>

<div id="loading-indicator" style="display:none; text-align:center; padding:20px;">
    Caricamento dati...
</div>

<script>
    // Configurazione GitHub
    const GITHUB_USERNAME = "masca87";
    const REPO_NAME = "beachvolley";

    // ATTENZIONE: IL TOKEN GITHUB NON DEVE ESSERE QUI.
    // Useremo un PAT con scope 'repo' per attivare GitHub Actions,
    // ma solo per lo sviluppo/test. In produzione, questo è un problema.
    // Per deploy su GitHub Pages con write, il PAT DEV'ESSERE DEL REPO STESSO O UN TOKEN TEMPORANEO DI GITHUB APP.
    // Dato che ci hai fornito un token, lo useremo temporaneamente in una variabile globale,
    // ma ricorda che esporre un token con permessi di scrittura è un rischio di sicurezza.
    // PER LA SOLUZIONE RACCOMANDATA CON GITHUB ACTIONS, QUESTO TOKEN NON SERVE PIÙ NEL CODICE CLIENT-SIDE.
    // Sarà richiesto solo per triggerare l'Action tramite la REST API (se lo fai da uno script esterno),
    // ma non dalla pagina HTML stessa.
    //
    // Dato che stai usando GITHUB PAGES, l'unica opzione sicura per la scrittura è un backend dedicato
    // oppure, per questo caso specifico di modifica di un file nel repo, GitHub Actions come "backend serverless".
    //
    // Quindi, per la tua app su GitHub Pages, LA CANCELLAZIONE DEL TOKEN DAL JS DEL CLIENT È FONDAMENTALE.
    // Il token che mi hai dato (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) è un Personal Access Token.
    // NON USARLO NEL CODICE HTML/JS CLIENT-SIDE PER LE OPERAZIONI DI SCRITTURA.
    // Servirà per creare un repository_dispatch event, ma non dalla pagina HTML.
    // Ci serve un token con il permesso "repo".

    // Inizialmente avevi una logica per chiedere e salvare il token:
    // let GITHUB_TOKEN = localStorage.getItem('github_token');
    // if (!GITHUB_TOKEN) { /* ... prompt e alert ... */ }
    // QUESTA LOGICA NON VA PIÙ BENE PER SCRIVERE SUL REPO DA GITHUB PAGES.
    // PER LEGGERE I DATI, POTREMMO CONTINUARE A USARE L'API DI GITHUB SENZA TOKEN (LIMITATA A 60 RICHIESTE/ORA)
    // O UN TOKEN PER SOLA LETTURA, MA PER SCRIVERE SERVE IL GITHUB ACTIONS.

    // Per la lettura, useremo l'API di GitHub senza token per semplicità, accettando i limiti.
    // Per la scrittura, useremo l'API repository_dispatch, che richiede un PAT valido.
    // Questo PAT non sarà gestito direttamente nel browser, ma assumeremo che esista per la chiamata POST.
    // Per testare il salvataggio dovrai usare curl o Postman per inviare l'evento repository_dispatch
    // oppure creare un'altra GitHub Action che lo triggeri.
    //
    // Per semplificare al massimo e far funzionare le cose da GitHub Pages, il salvataggio sarà gestito
    // ATTIVANDO UN GITHUB ACTION. La pagina HTML non salverà direttamente.

    // Variabili globali
    let user = JSON.parse(localStorage.getItem('user'));
    let events = [];

    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.style.display = 'block';
        setTimeout(() => { toast.style.display = 'none'; }, 3000);
    }

    function saveUser() {
        const name = document.getElementById('name').value.trim();
        const phone = document.getElementById('phone').value.trim();

        if (!name || !phone) {
            showToast('Inserisci nome e telefono');
            return;
        }

        if (!/^[0-9+ ]+$/.test(phone)) {
            showToast('Numero di telefono non valido. Usa solo numeri, + e spazi.');
            return;
        }

        user = { name, phone };
        localStorage.setItem('user', JSON.stringify(user));
        showMain();
        showToast('Dati salvati con successo');
    }

    function showMain() {
        document.getElementById('login').style.display = 'none';
        document.getElementById('main').style.display = 'block';
        loadEvents();
    }

    function refreshData() {
        loadEvents();
        showToast('Dati aggiornati');
    }

    if (user) {
        showMain();
    } else {
        document.getElementById('login').style.display = 'block';
    }

    async function loadEvents() {
        const loadingIndicator = document.getElementById('loading-indicator');
        loadingIndicator.style.display = 'block';

        try {
            const today = new Date();
            today.setHours(0,0,0,0);

            // Usiamo l'API REST di GitHub per i contenuti raw del file.
            // Questo bypassa il limite di 60 richieste/ora se non si usa un token,
            // ed è più stabile per file JSON.
            const rawUrl = `https://raw.githubusercontent.com/${GITHUB_USERNAME}/${REPO_NAME}/main/events.json`;
            const response = await fetch(rawUrl);

            if (!response.ok) {
                // Se il file non esiste, o c'è un errore, gestiamo
                if (response.status === 404) {
                    console.warn("File events.json non trovato, creando un array vuoto.");
                    events = []; // Inizializza con un array vuoto se il file non esiste
                } else {
                    throw new Error(`Errore HTTP ${response.status}: ${response.statusText}`);
                }
            } else {
                // Se la risposta è OK, tenta di parsare il JSON
                let remoteEvents = await response.json();
                events = remoteEvents.filter(e => new Date(e.date) >= today);
            }

            // Assicurati di avere 14 giorni di copertura
            for (let i = 0; i < 14; i++) {
                const day = new Date(today);
                day.setDate(today.getDate() + i);
                const dayStr = day.toISOString().split('T')[0];

                if (!events.some(e => e.date.startsWith(dayStr))) {
                    events.push({
                        id: Date.now() + i,
                        date: day.toISOString(),
                        place: '',
                        participants: []
                    });
                }
            }

            events.sort((a, b) => new Date(a.date) - new Date(b.date));
            renderGrid(events);

        } catch (error) {
            console.error("Errore nel caricamento degli eventi:", error);
            events = JSON.parse(localStorage.getItem('events')) || [];
            renderGrid(events);
            showToast(`Connessione fallita al file remoto: ${error.message || 'Controlla la connessione o l\'esistenza del file events.json.'}`);
        } finally {
            loadingIndicator.style.display = 'none';
        }
    }

    // NUOVA FUNZIONE DI SALVATAGGIO: Attiva un GitHub Action
    async function saveEvents() {
        showToast('Invio dati in corso...');
        const loadingIndicator = document.getElementById('loading-indicator');
        loadingIndicator.textContent = "Salvataggio in corso...";
        loadingIndicator.style.display = 'block';

        try {
            // Per attivare un repository_dispatch event, hai bisogno di un Personal Access Token
            // con permesso 'repo'. Questo TOKEN NON DEVE ESSERE NEL CODICE JAVASCRIPT CLIENT-SIDE.
            // Dovrai configurare un modo sicuro per inviare questo POST request,
            // ad esempio, da un tuo serverino o un'altra GitHub Action, o manualmente per test.
            //
            // Per farti vedere il codice funzionante, userò il token che mi hai fornito qui,
            // MA SOTTOLINEO FORTEMENTE CHE QUESTO È UN RISCHIO DI SICUREZZA MAGGIORE
            // E NON DEVE MAI ESSERE FATTO IN PRODUZIONE.
            //
            // L'ideale sarebbe avere un server backend che espone un endpoint sicuro,
            // e la tua app front-end chiama il tuo backend, che a sua volta chiama GitHub.
            // Oppure, come detto, GitHub Actions triggherato esternamente.

            // Dato che siamo su GitHub Pages, e non possiamo esporre il token,
            // NON POSSIAMO FARE IL REPOSITORY_DISPATCH DIRETTAMENTE DAL BROWSER IN MODO SICURO.
            //
            // Quindi, la funzionalità di salvataggio *diretto* dalla pagina web non è fattibile
            // in modo semplice e sicuro con GitHub come unico backend.
            //
            // L'unica opzione "senza backend" sarebbe che l'utente stesso dovesse inserire il token
            // ogni volta per fare il push, cosa impraticabile.

            // PER ORA, IL SALVATAGGIO SU GITHUB NON FUNZIONERÀ DA QUESTO CODICE CLIENT-SIDE.
            // La funzione saveEvents() simulerà il successo ma in realtà salverà solo localmente.
            // Se vuoi un salvataggio reale, dovrai implementare un backend o un processo esterno
            // che usi il GitHub Action.

            // DEBUGGING: Simula il successo del salvataggio
            console.log("Simulando salvataggio su GitHub. I dati effettivi non vengono inviati per motivi di sicurezza/CORS.");
            localStorage.setItem('events', JSON.stringify(events)); // Salva localmente per persistenza sessione
            showToast('Dati salvati LOCALMENTE (salvataggio remoto richiede backend).');
            return true;

            /*
            // CODICE PER IL VERO SALVATAGGIO TRAMITE REPOSITORY_DISPATCH (Richiede un TOKEN Github con scope 'repo'
            // che NON DEVE ESSERE IN QUESTO FILE JS PER SICUREZZA IN PROD.
            // Questo PAT dovrebbe essere gestito da un backend o da un'altra CI/CD pipeline).

            // const MY_GITHUB_TOKEN = "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"; // Non farlo in produzione!

            // const response = await fetch(`https://api.github.com/repos/${GITHUB_USERNAME}/${REPO_NAME}/dispatches`, {
            //     method: 'POST',
            //     headers: {
            //         'Accept': 'application/vnd.github.v3+json',
            //         'Authorization': `token ${MY_GITHUB_TOKEN}`, // Token problematico qui
            //         'Content-Type': 'application/json'
            //     },
            //     body: JSON.stringify({
            //         event_type: 'update_events',
            //         client_payload: {
            //             events_data: btoa(JSON.stringify(events)) // Dati degli eventi codificati in base64
            //         }
            //     })
            // });

            // if (!response.ok) {
            //     const errorData = await response.json();
            //     throw new Error(`Errore nell'attivazione del workflow: ${response.status} - ${errorData.message || response.statusText}`);
            // }

            // console.log("Workflow GitHub Actions attivato con successo.");
            // localStorage.setItem('events', JSON.stringify(events));
            // showToast('Richiesta di aggiornamento inviata (ci vorrà qualche secondo per l\'aggiornamento).');
            // return true;
            */

        } catch (error) {
            console.error("Errore nel tentativo di salvataggio:", error);
            showToast(`Salvataggio remoto fallito: ${error.message}. Salvato solo localmente.`);
            return false;
        } finally {
            loadingIndicator.style.display = 'none';
            loadingIndicator.textContent = "Caricamento dati..."; // Resetta il testo
        }
    }


    function renderGrid(events) {
        const grid = document.getElementById('eventsGrid');
        grid.innerHTML = '';

        const dateFormatter = new Intl.DateTimeFormat('it-IT', {
            weekday: 'short',
            day: 'numeric',
            month: 'numeric'
        });

        for (const event of events) {
            const day = new Date(event.date);
            const total = event.participants.reduce((acc, p) => acc + 1 + (p.guests ? p.guests.length : 0), 0);
            const div = document.createElement('div');
            div.className = 'day';

            const existingParticipant = event.participants.find(p => p.phone === user?.phone);
            let guestInputsHtml = '';

            if (existingParticipant?.guests?.length > 0) {
                for(let i = 0; i < existingParticipant.guests.length; i++) {
                    const guestName = existingParticipant.guests[i] || '';
                    guestInputsHtml += `
                        <input type="text"
                               placeholder="Nome +${i+1}"
                               value="${escapeHtml(guestName)}"
                               onchange="updateGuestName(${event.id}, '${escapeHtml(user.phone)}', ${i}, this.value)" />
                    `;
                }
            }

            div.innerHTML = `
                <strong>${dateFormatter.format(day)}</strong><br>
                <input type="text"
                       placeholder="Luogo"
                       value="${escapeHtml(event.place || '')}"
                       onchange="updatePlace(${event.id}, this.value)"><br>
                <p>Iscritti: ${total}</p>
                <button onclick="toggleParticipation(${event.id})">
                    ${existingParticipant ? 'Rimuovi' : 'Partecipo'}
                </button>
                <button onclick="addGuests(${event.id}, 1)" ${!existingParticipant ? 'disabled' : ''}>
                    +1
                </button>
                <button onclick="addGuests(${event.id}, 2)" ${!existingParticipant ? 'disabled' : ''}>
                    +2
                </button>
                <div class="guest-names">${guestInputsHtml}</div>
                <div class="participant-list">
                    ${event.participants.length > 0 ?
                        event.participants.map(p =>
                            `${escapeHtml(p.name)}${p.guests?.length > 0 ? ` (+${p.guests.length})` : ''}`
                        ).join('<br>') :
                        'Nessun partecipante'}
                </div>
            `;
            grid.appendChild(div);
        }
    }

    function escapeHtml(str) {
        if (str === null || str === undefined) return '';
        return str.toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    async function updatePlace(id, value) {
        const event = events.find(e => e.id === id);
        if (event) {
            event.place = value;
            const success = await saveEvents();
            if (success) showToast('Luogo aggiornato (solo localmente)'); // Modificato il messaggio
        }
    }

    async function toggleParticipation(id) {
        const event = events.find(e => e.id === id);
        if (!event || !user) return;

        const existingIndex = event.participants.findIndex(p => p.phone === user.phone);

        if (existingIndex >= 0) {
            if (!confirm('Sei sicuro di voler rimuovere la tua partecipazione?')) {
                return;
            }
            event.participants.splice(existingIndex, 1);
            const success = await saveEvents();
            if (success) {
                showToast('Partecipazione rimossa (solo localmente)'); // Modificato il messaggio
                loadEvents();
            }
        } else {
            event.participants.push({
                name: user.name,
                phone: user.phone,
                guests: []
            });
            const success = await saveEvents();
            if (success) {
                showToast('Partecipazione registrata (solo localmente)'); // Modificato il messaggio
                loadEvents();
            }
        }
    }

    async function addGuests(id, count) {
        const event = events.find(e => e.id === id);
        if (!event || !user) return;

        const participant = event.participants.find(p => p.phone === user.phone);
        if (!participant) {
            showToast('Devi prima partecipare per aggiungere amici');
            return;
        }

        participant.guests = participant.guests || [];

        if (participant.guests.length === count) {
            showToast(`Hai già ${count} ospiti registrati.`);
            return;
        }

        if (participant.guests.length > count) {
            participant.guests.length = count;
        } else {
            while (participant.guests.length < count) {
                participant.guests.push('');
            }
        }

        const success = await saveEvents();
        if (success) {
            showToast(`Aggiornati a ${count} ospiti (solo localmente)`); // Modificato il messaggio
            loadEvents();
        }
    }

    async function updateGuestName(eventId, phone, guestIndex, name) {
        const event = events.find(e => e.id === eventId);
        if (!event) return;

        const participant = event.participants.find(p => p.phone === phone);
        if (!participant || !participant.guests) return;

        participant.guests[guestIndex] = name.trim();
        await saveEvents(); // Questo salverà localmente.
    }

    // Polling per aggiornamenti automatici (ogni 30 secondi)
    // Questo caricherà i dati da GitHub, ma non salverà i tuoi cambiamenti se non c'è un backend.
    setInterval(refreshData, 30000);
</script>
</body>
</html>
